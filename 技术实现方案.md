# 项目任务管理软件技术实现方案

## 1. 项目结构分析

### 1.1 现有项目结构
```
src/
├── components/          # 可复用组件
│   ├── Header.js       # 顶部导航栏
│   ├── Sidebar.js      # 侧边栏导航
│   ├── ProjectCard.js  # 项目卡片组件
│   ├── TaskList.js     # 任务列表组件
│   ├── ProgressChart.js # 进度图表组件
│   └── StatCard.js     # 统计卡片组件
├── pages/              # 页面组件
│   ├── Dashboard.js    # 仪表盘页面
│   ├── Projects.js     # 项目管理页面
│   ├── Tasks.js        # 任务管理页面
│   ├── Analytics.js    # 数据分析页面
│   └── Settings.js     # 设置页面
├── App.js              # 主应用组件
├── index.js            # 应用入口
└── index.css           # 全局样式
```

### 1.2 技术栈分析
- **前端框架**: React 18.2.0
- **路由管理**: React Router DOM 6.8.0
- **图表库**: Recharts 2.5.0
- **图标库**: Lucide React 0.263.1
- **动画库**: Framer Motion 10.12.0
- **工具库**: date-fns 2.29.3, clsx 1.2.1

## 2. 功能模块实现方案

### 2.1 项目管理模块

#### 2.1.1 项目数据结构
```javascript
// 项目数据模型
const projectSchema = {
  id: String,
  name: String,           // 项目名称
  description: String,    // 项目描述
  department: String,     // 所属部门
  status: 'active' | 'completed' | 'paused' | 'cancelled',
  owner: String,          // 项目负责人ID
  members: [String],      // 项目成员ID列表
  startDate: Date,        // 计划开始时间
  endDate: Date,          // 计划结束时间
  priority: 'high' | 'medium' | 'low',
  tags: [String],         // 项目标签
  progress: Number,       // 进度百分比
  createdAt: Date,
  updatedAt: Date
};
```

#### 2.1.2 项目列表组件实现
```javascript
// src/components/ProjectList.js
import React, { useState, useEffect } from 'react';
import { ProjectCard } from './ProjectCard';
import { SearchBar } from './SearchBar';
import { FilterPanel } from './FilterPanel';

const ProjectList = () => {
  const [projects, setProjects] = useState([]);
  const [filteredProjects, setFilteredProjects] = useState([]);
  const [filters, setFilters] = useState({
    status: 'all',
    department: 'all',
    priority: 'all',
    dateRange: null
  });

  // 获取项目列表
  useEffect(() => {
    fetchProjects();
  }, []);

  // 筛选项目
  useEffect(() => {
    applyFilters();
  }, [projects, filters]);

  const fetchProjects = async () => {
    // API调用获取项目列表
    const response = await fetch('/api/projects');
    const data = await response.json();
    setProjects(data);
  };

  const applyFilters = () => {
    let filtered = projects;
    
    if (filters.status !== 'all') {
      filtered = filtered.filter(p => p.status === filters.status);
    }
    
    if (filters.department !== 'all') {
      filtered = filtered.filter(p => p.department === filters.department);
    }
    
    if (filters.priority !== 'all') {
      filtered = filtered.filter(p => p.priority === filters.priority);
    }
    
    setFilteredProjects(filtered);
  };

  return (
    <div className="project-list">
      <div className="project-list-header">
        <SearchBar onSearch={handleSearch} />
        <FilterPanel filters={filters} onFilterChange={setFilters} />
      </div>
      <div className="project-grid">
        {filteredProjects.map(project => (
          <ProjectCard key={project.id} project={project} />
        ))}
      </div>
    </div>
  );
};
```

### 2.2 任务管理模块

#### 2.2.1 任务数据结构
```javascript
// 任务数据模型
const taskSchema = {
  id: String,
  name: String,           // 任务名称
  description: String,    // 任务描述
  projectId: String,      // 所属项目ID
  assignee: String,       // 任务负责人ID
  members: [String],      // 任务成员ID列表
  status: 'pending' | 'in-progress' | 'review' | 'completed' | 'paused' | 'cancelled',
  priority: 'high' | 'medium' | 'low',
  type: 'development' | 'design' | 'testing' | 'documentation' | 'other',
  startDate: Date,        // 计划开始时间
  endDate: Date,          // 计划结束时间
  estimatedHours: Number, // 预估工时
  actualHours: Number,    // 实际工时
  progress: Number,       // 完成百分比
  dependencies: [String], // 依赖任务ID列表
  createdAt: Date,
  updatedAt: Date
};
```

#### 2.2.2 任务列表组件实现
```javascript
// src/components/TaskList.js
import React, { useState, useEffect } from 'react';
import { TaskCard } from './TaskCard';
import { TaskStatusFilter } from './TaskStatusFilter';
import { TaskProgressBar } from './TaskProgressBar';

const TaskList = ({ projectId }) => {
  const [tasks, setTasks] = useState([]);
  const [statusFilter, setStatusFilter] = useState('all');

  useEffect(() => {
    fetchTasks(projectId);
  }, [projectId]);

  const fetchTasks = async (projectId) => {
    const response = await fetch(`/api/projects/${projectId}/tasks`);
    const data = await response.json();
    setTasks(data);
  };

  const updateTaskStatus = async (taskId, newStatus) => {
    const response = await fetch(`/api/tasks/${taskId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status: newStatus })
    });
    
    if (response.ok) {
      fetchTasks(projectId); // 重新获取任务列表
    }
  };

  const filteredTasks = statusFilter === 'all' 
    ? tasks 
    : tasks.filter(task => task.status === statusFilter);

  return (
    <div className="task-list">
      <div className="task-list-header">
        <TaskStatusFilter 
          value={statusFilter} 
          onChange={setStatusFilter} 
        />
        <button className="btn-primary">新建任务</button>
      </div>
      <div className="task-items">
        {filteredTasks.map(task => (
          <TaskCard 
            key={task.id} 
            task={task}
            onStatusChange={updateTaskStatus}
          />
        ))}
      </div>
    </div>
  );
};
```

### 2.3 进度可视化模块

#### 2.3.1 甘特图组件实现
```javascript
// src/components/GanttChart.js
import React, { useState, useEffect } from 'react';
import { format, addDays, differenceInDays } from 'date-fns';
import { motion } from 'framer-motion';

const GanttChart = ({ projectId }) => {
  const [tasks, setTasks] = useState([]);
  const [timeline, setTimeline] = useState({
    start: new Date(),
    end: new Date(),
    scale: 'day'
  });

  useEffect(() => {
    fetchProjectTasks(projectId);
  }, [projectId]);

  const fetchProjectTasks = async (projectId) => {
    const response = await fetch(`/api/projects/${projectId}/tasks`);
    const data = await response.json();
    setTasks(data);
    
    // 计算时间轴范围
    const dates = data.flatMap(task => [task.startDate, task.endDate]);
    const minDate = new Date(Math.min(...dates));
    const maxDate = new Date(Math.max(...dates));
    
    setTimeline({
      start: minDate,
      end: maxDate,
      scale: 'day'
    });
  };

  const getTaskPosition = (task) => {
    const totalDays = differenceInDays(timeline.end, timeline.start);
    const taskStart = differenceInDays(task.startDate, timeline.start);
    const taskDuration = differenceInDays(task.endDate, task.startDate);
    
    return {
      left: `${(taskStart / totalDays) * 100}%`,
      width: `${(taskDuration / totalDays) * 100}%`
    };
  };

  return (
    <div className="gantt-chart">
      <div className="gantt-header">
        <h3>项目甘特图</h3>
        <div className="timeline-controls">
          <button onClick={() => setTimeline({...timeline, scale: 'day'})}>日</button>
          <button onClick={() => setTimeline({...timeline, scale: 'week'})}>周</button>
          <button onClick={() => setTimeline({...timeline, scale: 'month'})}>月</button>
        </div>
      </div>
      
      <div className="gantt-timeline">
        {/* 时间轴 */}
        <div className="timeline-axis">
          {generateTimelineLabels(timeline)}
        </div>
        
        {/* 任务条 */}
        <div className="task-bars">
          {tasks.map(task => {
            const position = getTaskPosition(task);
            return (
              <motion.div
                key={task.id}
                className={`task-bar task-${task.status}`}
                style={position}
                initial={{ opacity: 0, scale: 0.8 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ duration: 0.3 }}
              >
                <div className="task-label">{task.name}</div>
                <div className="task-progress" style={{width: `${task.progress}%`}} />
              </motion.div>
            );
          })}
        </div>
      </div>
    </div>
  );
};
```

#### 2.3.2 进度统计图表实现
```javascript
// src/components/ProgressChart.js
import React from 'react';
import { PieChart, Pie, Cell, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';

const ProgressChart = ({ projectData }) => {
  // 项目完成率数据
  const completionData = [
    { name: '已完成', value: projectData.completed, color: '#10B981' },
    { name: '进行中', value: projectData.inProgress, color: '#3B82F6' },
    { name: '待开始', value: projectData.pending, color: '#6B7280' },
    { name: '已暂停', value: projectData.paused, color: '#F59E0B' }
  ];

  // 任务状态分布数据
  const taskStatusData = [
    { status: '已完成', count: projectData.taskStatus.completed },
    { status: '进行中', count: projectData.taskStatus.inProgress },
    { status: '待验收', count: projectData.taskStatus.review },
    { status: '待开始', count: projectData.taskStatus.pending }
  ];

  return (
    <div className="progress-charts">
      <div className="chart-container">
        <h4>项目完成率</h4>
        <PieChart width={300} height={300}>
          <Pie
            data={completionData}
            cx={150}
            cy={150}
            innerRadius={60}
            outerRadius={120}
            paddingAngle={5}
            dataKey="value"
          >
            {completionData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={entry.color} />
            ))}
          </Pie>
          <Tooltip />
        </PieChart>
      </div>
      
      <div className="chart-container">
        <h4>任务状态分布</h4>
        <BarChart width={400} height={300} data={taskStatusData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="status" />
          <YAxis />
          <Tooltip />
          <Bar dataKey="count" fill="#3B82F6" />
        </BarChart>
      </div>
    </div>
  );
};
```

### 2.4 智能预警模块

#### 2.4.1 预警规则引擎
```javascript
// src/utils/alertEngine.js
export class AlertEngine {
  constructor() {
    this.rules = [
      {
        id: 'task_overdue',
        name: '任务延期预警',
        condition: (task) => {
          const now = new Date();
          const deadline = new Date(task.endDate);
          const daysUntilDeadline = Math.ceil((deadline - now) / (1000 * 60 * 60 * 24));
          return daysUntilDeadline <= 3 && daysUntilDeadline > 0 && task.status !== 'completed';
        },
        message: (task) => `任务"${task.name}"将在${Math.ceil((new Date(task.endDate) - new Date()) / (1000 * 60 * 60 * 24))}天后到期`,
        priority: 'high'
      },
      {
        id: 'project_delay',
        name: '项目延期预警',
        condition: (project) => {
          const progress = project.progress || 0;
          const expectedProgress = this.calculateExpectedProgress(project);
          return progress < expectedProgress - 10; // 进度滞后10%以上
        },
        message: (project) => `项目"${project.name}"进度滞后，当前进度${project.progress}%`,
        priority: 'medium'
      },
      {
        id: 'workload_overload',
        name: '工作量超载预警',
        condition: (user) => {
          const activeTasks = user.tasks.filter(t => t.status === 'in-progress');
          return activeTasks.length > 5; // 超过5个进行中任务
        },
        message: (user) => `用户${user.name}当前有${user.tasks.filter(t => t.status === 'in-progress').length}个进行中任务，可能存在工作量超载`,
        priority: 'medium'
      }
    ];
  }

  calculateExpectedProgress(project) {
    const now = new Date();
    const startDate = new Date(project.startDate);
    const endDate = new Date(project.endDate);
    const totalDuration = endDate - startDate;
    const elapsed = now - startDate;
    return Math.min(100, Math.max(0, (elapsed / totalDuration) * 100));
  }

  checkAlerts(data) {
    const alerts = [];
    
    // 检查任务预警
    if (data.tasks) {
      data.tasks.forEach(task => {
        this.rules.forEach(rule => {
          if (rule.condition(task)) {
            alerts.push({
              id: `${rule.id}_${task.id}`,
              type: rule.id,
              targetId: task.id,
              targetType: 'task',
              message: rule.message(task),
              priority: rule.priority,
              createdAt: new Date()
            });
          }
        });
      });
    }
    
    // 检查项目预警
    if (data.projects) {
      data.projects.forEach(project => {
        this.rules.forEach(rule => {
          if (rule.condition(project)) {
            alerts.push({
              id: `${rule.id}_${project.id}`,
              type: rule.id,
              targetId: project.id,
              targetType: 'project',
              message: rule.message(project),
              priority: rule.priority,
              createdAt: new Date()
            });
          }
        });
      });
    }
    
    return alerts;
  }
}
```

#### 2.4.2 预警通知组件
```javascript
// src/components/AlertNotification.js
import React, { useState, useEffect } from 'react';
import { Bell, AlertTriangle, Info, X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const AlertNotification = () => {
  const [alerts, setAlerts] = useState([]);
  const [isOpen, setIsOpen] = useState(false);

  useEffect(() => {
    // 定期检查预警
    const interval = setInterval(checkAlerts, 300000); // 5分钟检查一次
    return () => clearInterval(interval);
  }, []);

  const checkAlerts = async () => {
    const response = await fetch('/api/alerts/check');
    const newAlerts = await response.json();
    setAlerts(prev => [...newAlerts, ...prev]);
  };

  const markAsRead = async (alertId) => {
    await fetch(`/api/alerts/${alertId}/read`, { method: 'PATCH' });
    setAlerts(prev => prev.filter(alert => alert.id !== alertId));
  };

  const getAlertIcon = (priority) => {
    switch (priority) {
      case 'high':
        return <AlertTriangle className="text-red-500" />;
      case 'medium':
        return <AlertTriangle className="text-yellow-500" />;
      default:
        return <Info className="text-blue-500" />;
    }
  };

  return (
    <div className="alert-notification">
      <button 
        className="alert-toggle"
        onClick={() => setIsOpen(!isOpen)}
      >
        <Bell className="w-5 h-5" />
        {alerts.length > 0 && (
          <span className="alert-badge">{alerts.length}</span>
        )}
      </button>
      
      <AnimatePresence>
        {isOpen && (
          <motion.div 
            className="alert-panel"
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
          >
            <div className="alert-header">
              <h3>预警通知</h3>
              <button onClick={() => setIsOpen(false)}>
                <X className="w-4 h-4" />
              </button>
            </div>
            
            <div className="alert-list">
              {alerts.length === 0 ? (
                <div className="no-alerts">暂无预警</div>
              ) : (
                alerts.map(alert => (
                  <motion.div
                    key={alert.id}
                    className={`alert-item alert-${alert.priority}`}
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                  >
                    <div className="alert-icon">
                      {getAlertIcon(alert.priority)}
                    </div>
                    <div className="alert-content">
                      <p className="alert-message">{alert.message}</p>
                      <span className="alert-time">
                        {new Date(alert.createdAt).toLocaleString()}
                      </span>
                    </div>
                    <button 
                      className="alert-close"
                      onClick={() => markAsRead(alert.id)}
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </motion.div>
                ))
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};
```

## 3. 数据管理方案

### 3.1 状态管理
```javascript
// src/store/index.js
import { createContext, useContext, useReducer } from 'react';

const AppContext = createContext();

const initialState = {
  projects: [],
  tasks: [],
  users: [],
  alerts: [],
  currentUser: null,
  loading: false,
  error: null
};

const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_PROJECTS':
      return { ...state, projects: action.payload };
    case 'ADD_PROJECT':
      return { ...state, projects: [...state.projects, action.payload] };
    case 'UPDATE_PROJECT':
      return {
        ...state,
        projects: state.projects.map(p => 
          p.id === action.payload.id ? action.payload : p
        )
      };
    case 'SET_TASKS':
      return { ...state, tasks: action.payload };
    case 'ADD_TASK':
      return { ...state, tasks: [...state.tasks, action.payload] };
    case 'UPDATE_TASK':
      return {
        ...state,
        tasks: state.tasks.map(t => 
          t.id === action.payload.id ? action.payload : t
        )
      };
    case 'ADD_ALERT':
      return { ...state, alerts: [action.payload, ...state.alerts] };
    case 'REMOVE_ALERT':
      return {
        ...state,
        alerts: state.alerts.filter(a => a.id !== action.payload)
      };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    default:
      return state;
  }
};

export const AppProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
};

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};
```

### 3.2 API服务层
```javascript
// src/services/api.js
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api';

class ApiService {
  constructor() {
    this.baseURL = API_BASE_URL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }

  // 项目管理API
  async getProjects(filters = {}) {
    const params = new URLSearchParams(filters);
    return this.request(`/projects?${params}`);
  }

  async getProject(id) {
    return this.request(`/projects/${id}`);
  }

  async createProject(projectData) {
    return this.request('/projects', {
      method: 'POST',
      body: JSON.stringify(projectData)
    });
  }

  async updateProject(id, projectData) {
    return this.request(`/projects/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(projectData)
    });
  }

  async deleteProject(id) {
    return this.request(`/projects/${id}`, {
      method: 'DELETE'
    });
  }

  // 任务管理API
  async getTasks(projectId) {
    return this.request(`/projects/${projectId}/tasks`);
  }

  async createTask(taskData) {
    return this.request('/tasks', {
      method: 'POST',
      body: JSON.stringify(taskData)
    });
  }

  async updateTask(id, taskData) {
    return this.request(`/tasks/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(taskData)
    });
  }

  async deleteTask(id) {
    return this.request(`/tasks/${id}`, {
      method: 'DELETE'
    });
  }

  // 预警API
  async checkAlerts() {
    return this.request('/alerts/check');
  }

  async markAlertAsRead(id) {
    return this.request(`/alerts/${id}/read`, {
      method: 'PATCH'
    });
  }

  // 用户管理API
  async getUsers() {
    return this.request('/users');
  }

  async getCurrentUser() {
    return this.request('/users/me');
  }
}

export const apiService = new ApiService();
```

## 4. 部署方案

### 4.1 开发环境配置
```json
// package.json 补充配置
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "dev": "concurrently \"npm run start\" \"npm run server\"",
    "server": "json-server --watch db.json --port 3001"
  },
  "devDependencies": {
    "concurrently": "^7.6.0",
    "json-server": "^0.17.3"
  }
}
```

### 4.2 生产环境部署
```dockerfile
# Dockerfile
FROM node:18-alpine as build

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## 5. 测试策略

### 5.1 单元测试
```javascript
// src/components/__tests__/ProjectCard.test.js
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import ProjectCard from '../ProjectCard';

describe('ProjectCard', () => {
  const mockProject = {
    id: '1',
    name: '测试项目',
    description: '这是一个测试项目',
    status: 'active',
    progress: 75,
    priority: 'high'
  };

  test('renders project information correctly', () => {
    render(<ProjectCard project={mockProject} />);
    
    expect(screen.getByText('测试项目')).toBeInTheDocument();
    expect(screen.getByText('这是一个测试项目')).toBeInTheDocument();
    expect(screen.getByText('75%')).toBeInTheDocument();
  });

  test('calls onEdit when edit button is clicked', () => {
    const mockOnEdit = jest.fn();
    render(<ProjectCard project={mockProject} onEdit={mockOnEdit} />);
    
    fireEvent.click(screen.getByRole('button', { name: /编辑/i }));
    expect(mockOnEdit).toHaveBeenCalledWith(mockProject.id);
  });
});
```

### 5.2 集成测试
```javascript
// src/pages/__tests__/Projects.test.js
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { AppProvider } from '../../store';
import Projects from '../Projects';

describe('Projects Page', () => {
  beforeEach(() => {
    // Mock API calls
    global.fetch = jest.fn();
  });

  test('loads and displays projects', async () => {
    const mockProjects = [
      { id: '1', name: '项目1', status: 'active' },
      { id: '2', name: '项目2', status: 'completed' }
    ];

    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockProjects
    });

    render(
      <BrowserRouter>
        <AppProvider>
          <Projects />
        </AppProvider>
      </BrowserRouter>
    );

    await waitFor(() => {
      expect(screen.getByText('项目1')).toBeInTheDocument();
      expect(screen.getByText('项目2')).toBeInTheDocument();
    });
  });
});
```

## 6. 性能优化

### 6.1 代码分割
```javascript
// src/App.js
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Loading from './components/Loading';

// 懒加载页面组件
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Projects = lazy(() => import('./pages/Projects'));
const Tasks = lazy(() => import('./pages/Tasks'));
const Analytics = lazy(() => import('./pages/Analytics'));
const Settings = lazy(() => import('./pages/Settings'));

function App() {
  return (
    <Router>
      <Suspense fallback={<Loading />}>
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/projects" element={<Projects />} />
          <Route path="/tasks" element={<Tasks />} />
          <Route path="/analytics" element={<Analytics />} />
          <Route path="/settings" element={<Settings />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

### 6.2 虚拟滚动
```javascript
// src/components/VirtualizedList.js
import React, { useState, useEffect, useRef } from 'react';

const VirtualizedList = ({ items, itemHeight, renderItem }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(0);
  const containerRef = useRef();

  useEffect(() => {
    if (containerRef.current) {
      setContainerHeight(containerRef.current.clientHeight);
    }
  }, []);

  const visibleItemCount = Math.ceil(containerHeight / itemHeight);
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleItemCount, items.length);

  const visibleItems = items.slice(startIndex, endIndex);
  const totalHeight = items.length * itemHeight;
  const offsetY = startIndex * itemHeight;

  return (
    <div
      ref={containerRef}
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <div key={startIndex + index} style={{ height: itemHeight }}>
              {renderItem(item, startIndex + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

这个技术实现方案提供了完整的开发指导，包括：

1. **模块化组件设计**：每个功能模块都有清晰的组件结构
2. **数据管理方案**：使用Context API进行状态管理
3. **API服务层**：统一的API调用接口
4. **智能预警系统**：基于规则引擎的预警机制
5. **性能优化**：代码分割、虚拟滚动等优化策略
6. **测试策略**：单元测试和集成测试方案
7. **部署方案**：Docker容器化部署

基于现有的React项目结构，可以按照这个方案逐步实现PRD中的所有功能需求。
